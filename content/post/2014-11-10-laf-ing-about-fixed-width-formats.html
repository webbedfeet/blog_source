

<p>If you have ever worked with US government data or other large datasets, it is likely you have faced fixed-width format data. This format has no delimiters in it; the data look like strings of characters. A separate format file defines which columns of data represent which variables. It seems as if the format is from the punch-card era, but it is quite an efficient format to store large data in (see this <a href="http://stackoverflow.com/questions/7666780/why-are-fixed-width-file-formats-still-in-use">StackOverflow discussion</a>). However, it requires quite a bit of coding, in terms of defining which columns represent which variables.</p>
<p>A recent project that our group at NIH is working on involves the National Inpatient Sample (<a href="http://www.hcup-us.ahrq.gov/">NIS</a>) from the Healthcare Cost and Utilization Project (<a href="http://www.hcup-us.ahrq.gov/">HCUP</a>). The current task is to load the Core data (8.2M records for 2008), filter it for a particular set of <a href="http://en.wikipedia.org/wiki/Diagnosis-related_group">DRG codes</a>, and see how many discharges with these DRG codes are present in each hospital in the set of hospitals included in the sample. Furthermore, we need to categorize each hospital as low, medium and high volume hospitals based on the number of discharges.</p>
<blockquote>
Note that to protect our project, I will not use the DRG codes that we’re actually using. I actually don’t know what DRG=500 is in terms of what the patient undergoes.
</blockquote>
<div id="translating-available-code" class="section level2">
<h2>Translating available code</h2>
<p>HCUP provides load files for their data sets in SAS, SPSS and Stata. Note that no open-source data software made the cut, possibly for legacy reasons. This post will focus on a <a href="http://www.r-project.org">R</a> based solution. A follow up post will present a <a href="http://www.python.org">Python</a> based solution.</p>
<p>First of all, I admit that I am lazy. I don’t want to sit with the data dictionary and write out all the format statements in R. However, if HCUP is providing load files, why not use them? Looking at them, I felt that the Stata load file was cleanest in terms of formatting. I wrote the following R script to extract variable names, column widths and formats (string, double, or integer) from the load file.</p>
<pre class="r"><code>parseStataCode &lt;- function(statafile){
 require(stringr)
 options(stringsAsFactors=FALSE)
 statacode &lt;- readLines(statafile)
 indStart &lt;- min(grep(&#39;infix&#39;, statacode))
 indEnd &lt;- min(grep(&#39;using&#39;, statacode))-1
 codelines &lt;- statacode[indStart:indEnd]
 codelines[1] &lt;- gsub(&#39;infix&#39;,&#39;&#39;, codelines[1])
 codelines = str_trim(codelines)
 types &lt;- str_extract(codelines, &#39;^\\w+&#39;)
 translate &lt;- c(&#39;int&#39;=&#39;integer&#39;, &#39;byte&#39;=&#39;integer&#39;, &#39;str&#39;=&#39;string&#39;, &#39;double&#39;=&#39;double&#39;, &#39;long&#39;=&#39;double&#39;)
 types2 &lt;- translate[types]
 varnames &lt;- str_extract(codelines, &#39;[A-Z]\\w+&#39;)
 startcols &lt;- as.integer(str_extract(codelines,&#39; \\d+&#39;))
 maxcols = unlist(str_extract_all(codelines,&#39;\\d+&#39;))
 startcols = c(startcols, as.integer(maxcols[length(maxcols)]))
 widths = diff(startcols)
 return(data.frame(varnames = varnames, widths=widths, classes=types2))
}</code></pre>
<p>You can of course add more code to extract missing value definitions and the like, but this sufficed for my current purpose.</p>
<blockquote>
My friend Anthony Damico wrote a great little package in R called <a href="http://cran.r-project.org/package=SAScii">SAScii</a>, for the purpose of translating SAS load files provided by different US Government agencies for publicly available data (see his site <a href="http://www.asdfree.com">ASDFree</a> for several nice examples with large government surveys). However, the HCUP SAS load files contain custom formatting statements that breaks Anthony’s code. Hence the need to create my own translation code.
</blockquote>
</div>
<div id="ingesting-data" class="section level2">
<h2>Ingesting data</h2>
<p>Now on to the actual job of reading the data. R provides a function read.fwf, but that is painfully slow, so I immediately went to the Gods of Google. A quick internet search found the package <a href="http://cran.r-project.org/package=LaF">LaF</a>, which uses C++ underneath to make accessing large ASCII files faster. LaF also allows some column selection and filtering as data is loaded into memory in R. The workhorse for this is the <a href="http://www.inside-r.org/packages/cran/LaF/docs/laf_open_fwf">laf_open_fwf</a> function, which requires specification of the column widths and types.</p>
<pre class="r"><code>wt &lt;- parseStataCode(&#39;StataLoad_NIS_2008_Core.Do&#39;)
d &lt;- laf_open_fwf(&#39;NIS_2008_Core.ASC&#39;, column_widths=wt$widths,
 column_types=wt$classes, column_names = wt$varnames)</code></pre>
<p>The code above does not actually load the data into R, but essentially creates a pointer to the data on disk. Now I decided to use the (awesome) power of <a href="http://cran.r-project.org/package=dplyr">dplyr</a> and <a href="http://cran.r-project.org/package=magrittr">magrittr</a> to extract the frequencies I need. This strategy provides very clear and fast code that I’m happy with right now.</p>
<pre class="r"><code>d1 &lt;- d[,c(&quot;DRG&quot;,&quot;HOSPID&quot;)] %&gt;%                           # Select only columns I need
 dplyr::filter(DRG %in% c(500)) %&gt;%                       # Keep DRGs I want
 group_by(HOSPID) %&gt;%
 summarize(n=n()) %&gt;%                                     # Tabulate volumes by hospital
 mutate(volumeCat = cut(n, c(0,100,400,max(n)+1),
     labels=c(&#39;Low&#39;,&#39;Medium&#39;,&#39;High&#39;))) %&gt;%                # Categorize hospitals
 group_by(volumeCat) %&gt;%
 summarize(n=n())                                         # Tabulate hospital categories</code></pre>
<blockquote>
Why am I doing the filtering using dplyr rather than LaF? At least for my initial runs, it seemed that the dplyr strategy is faster. You could, in fact, use LaF as follows: <code>d[d[,&quot;DRG&quot;] %in% c(500), c(&quot;DRG&quot;,&quot;HOSPID&quot;)].</code>See the LaF user manual for details about the syntax for row filtering, since it is a bit idiosyncratic.
</blockquote>
<p>So how does this actually perform? We’re working with 8.2 million records here. I ran my code (after wrapping it in a function) on my desktop (Intel Xeon <span class="citation">@2.67</span> Ghz, 8GB RAM running Windows 7 64-bit Enterprise Edition, running R 3.1.1).</p>
<pre><code>system.time(freq &lt;- zip2freq(&#39;NIS_2008_Core.ASC&#39;, drg=c(500)))
user system elapsed
3.19 1.57 45.56</code></pre>
<p>On my MacBook Air (2014) with 8GB memory and a 1.4 GHz Intel Core i5 and a Solid State Disk, this took about 16 seconds (elapsed time).</p>
<p>For contrast, I used the HCUP-supplied <a href="http://www.hcup-us.ahrq.gov/db/nation/nis/tools/pgms/SASLoad_NIS_2008_Core.SAS">SAS load file</a> (on SAS 9.3), adding the lines</p>
<pre class="sas"><code>if DRG=500;
keep DRG HOSPID;</code></pre>
<p>to the end of the provided DATA statement to filter the data and keep only the two variables I need. I’m not good enough in SAS to do the remaining data munging efficiently, but the timings were interesting to say the least.</p>
<pre><code>NOTE: 8158381 records were read from the infile &#39;H:\tmp\NIS_2008_Core.ASC&#39;. The minimum record length was 516. The maximum record length was 516. NOTE: The data set WORK.NIS_2008_CORE has 1068 observations and 2 variables. NOTE: DATA statement used (Total process time): real time 2:26.37 cpu time 2:11.15</code></pre>
</div>
